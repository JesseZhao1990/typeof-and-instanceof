{
  "name": "Typeof-and-instanceof",
  "tagline": "总结typeof 和 instanceof",
  "body": "## typeof 和 instanceof ##\r\njs中typeof和instanceof一般用来判断变量类型。由于js这门语言本身设计的缺陷。导致有很多令人困惑和感觉起来不合理的地方。比如说js声称自己有五种基本数据类型undefined, null, boolean, number and string。但是扯淡的是。。。当你用typeof判断这些基本类型时。奇葩的事情就出现了。比如说typeof null竟然是object。那是不是null是引用数据类型呢？其实不是……它真的是基本数据类型。这是一个bug。有人提议把这个bug修改掉。但是被残忍的拒绝了…………\r\n\r\n想要搞清楚下面的问题。首先要清楚基本数据类型和引用数据类型\r\n\r\n**基本数据类型**\r\n\r\n基本数据类型包含五种：undefined, null, boolean, number 和 string\r\n\r\n**引用数据类型**\r\n\r\n所有的非基本数据类型都是引用数据类型。也就是对象。你可以给引用数据类型添加属性，但是不能给基本数据类型添加属性\r\n\r\n\r\n### typeof ###\r\n首先先看标准怎么说的。\r\n[标准的链接](http://www.ecma-international.org/ecma-262/5.1/#sec-11.4.3)\r\n\r\n翻译过来是这样描述的\r\n\r\ntypeof操作符的用法\r\n\r\ntypeof val. 执行一元表达式得到一个值。下面是一些值和结果的对照关系：\r\n\r\n```\r\n\r\nundefined\t---> “undeifined\"\r\n\r\nnull ---> “object\"\r\n\r\nBoolean ---> “boolean\"\r\n\r\nNumber ---> “number\"\r\n\r\nString ---> “string\"\r\n\r\nFunction ---> “function\"\r\n\r\n其他值 ---> “object\"\r\n\r\n```\r\ntypeof null返回object是一个bug，但是不能修复，因为它会破坏现在存在的代码。注意，function也是一个对象，但是typeof做了区分，Array也是一个对象。但是typeof没有作区分。这就是js的设计者做的很多不完美的地方。留了很多缺陷。有一篇文章详细剖析了type of 返回object 这一个bug的具体信息。可以点击[这里](http://www.2ality.com/2013/10/typeof-null.html)查看\r\n\r\n### instanceof ###\r\ninstanceof检测值是不是一个构造函数的实例。但这里需要注意的是基本数据类型使用instanceof都会返回false。\r\n\r\n```\r\n\"aaa\" instanceof String  //false\r\n\r\nvar a = new String(\"aaa\") \r\na instanceof String  //true\r\n\r\n```\r\n思考一下以上两种方式为何会出现不同的结果? 为什么\"aaa\".length和\"aaa\".subString()这些String对象上的方法可以被基本数据类型使用。其实可以这样去理解，基本数据类型自身不是对象。但是在运行环境中。js会自动帮他们生产虚拟的对象。运行结束之后，这些虚拟对象被销毁。\r\n\r\n那接下来思考一下几个问题：\r\n\r\n1.如何判断一个变量不存在？（是undefined或者null）\r\n\r\n```\r\n\r\nfunction isNothing(subject) {\r\n  return (undefined === subject) || (null === subject);\r\n}\r\n\r\n```\r\n\r\n2.如何判断一个变量是对象? （不是函数，也不是基本数据类型。）\r\n\r\n```\r\n\r\nfunction isObject(subject) {\r\n  return ('object' === typeof subject) && (null !== subject);\r\n}\r\n\r\n```\r\n\r\n3.如何判断一个变量是数组？\r\n\r\n最简单的方法是如下写法。\r\n\r\n```\r\nfunction isArray(value){\r\n\treturn value instanceof Array;\t\r\n}\r\n\r\n```\r\n这样写一般也不会遇到啥大问题。但是[在不同 iframe 中创建的 Array 并不共享 prototype](http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/)\r\n\r\n所以想要严谨一些。兼容iframe这种情况的话。可以用如下的方法。\r\n\r\n原理：Object.prototype.toString对任何变量会永远返回这样一个字符串\"[object class]\"，而这个class就是JavaScript内嵌对象的构造函数的名字。至于用户自定义的变量，则class等于object。因此通过Object.prototype.toString.apply(obj)可以准确的获取变量数据类型。通过Object.prototype.toString可以获得的数据类型包括：Date, Object, String, Number, Boolean, Regexp, Function, undefined, null, Math等。\r\n\r\n```\r\n\r\nvar isArray = function(obj) { \r\n    return Object.prototype.toString.call(obj) === '[object Array]'; \r\n}\r\n\r\n```\r\n**注意：**在ES5中增加了新的原生的方法。[参见](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)\r\n\r\n```\r\nArray.isArray(obj)\r\n\r\n```\r\n\r\n由于刚刚那种写法不是原生的写法。效率会低一些。如果想兼容所有浏览器。首先用能力检查。看支持不支持Array.isArray。支持的话直接用。不支持的话再用其他方法。\r\n\r\n```\r\nvar isArray = function(obj){\r\n\tif (!Array.isArray){\r\n\t\treturn Object.prototype.toString.call(obj) === '[object Array]'; \r\n\t}else{\r\n\t\treturn Array.isArray(obj)\r\n\t}\r\n}\r\n\r\n```\r\n\r\n4.如何判断一个变量是string类型？\r\n\r\n```\r\nfunction isString(s){\r\n\tif(typeof s == \"string\"){\r\n\t\treturn true;\r\n\t}else if(typeof s ==\"object\" && s instanceof== \"String\"){\r\n\t\treturn true;\r\n\t}else{\r\n\t\treturn false;\r\n\t}\r\n}\r\n\r\n```\r\n5.如何判断一个变量是function类型？\r\n\r\n```\r\nfunction isFunction(obj){\r\n\treturn typeof(obj)==\"function\";\r\n}\r\n\r\n```\r\n\r\n6.写一个通用的判断各种类型的方法如何？\r\n\r\n```\r\nvar is = function (obj,type) { \r\n\treturn (type === \"Null\" && obj === null) || \r\n\t\t\t(type === \"Undefined\" && obj === void 0 ) || \r\n\t\t\t(type === \"Number\" && isFinite(obj)) || \r\n\t\t\tObject.prototype.toString.call(obj).slice(8,-1) === type; \r\n}\r\n\r\n```\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}