{
  "name": "Typeof-and-instanceof",
  "tagline": "总结typeof 和 instanceof",
  "body": "## typeof 和 instanceof ##\r\njs中typeof和instanceof一般用来判断变量类型。由于js这门语言本身设计的缺陷。导致有很多令人困惑和感觉起来不合理的地方。比如说js声称自己有五种基本数据类型undefined, null, boolean, number and string。但是扯淡的是。。。当你用typeof判断这些基本类型时。奇葩的事情就出现了。比如说typeof null竟然是object。那是不是null是引用数据类型呢？其实不是……它真的是基本数据类型。这是一个bug。有人提议把这个bug修改掉。但是被残忍的拒绝了…………\r\n\r\n想要搞清楚下面的问题。首先要清楚基本数据类型和引用数据类型\r\n\r\n**基本数据类型**\r\n\r\n基本数据类型包含五种：undefined, null, boolean, number 和 string\r\n\r\n**引用数据类型**\r\n\r\n所有的非基本数据类型都是引用数据类型。也就是对象。你可以给引用数据类型添加属性，但是不能给基本数据类型添加属性\r\n\r\n\r\n### typeof ###\r\n首先先看标准怎么说的。\r\n[标准的链接](http://www.ecma-international.org/ecma-262/5.1/#sec-11.4.3)\r\n\r\n翻译过来是这样描述的\r\n\r\ntypeof操作符的用法\r\n\r\ntypeof val. 执行一元表达式得到一个值。下面是一些值和结果的对照关系：\r\n\r\n```\r\n\r\nundefined\t---> “undeifined\"\r\n\r\nnull ---> “object\"\r\n\r\nBoolean ---> “boolean\"\r\n\r\nNumber ---> “number\"\r\n\r\nString ---> “string\"\r\n\r\nFunction ---> “function\"\r\n\r\n其他值 ---> “object\"\r\n\r\n```\r\ntypeof null返回object是一个bug，但是不能修复，因为它会破坏现在存在的代码。注意，function也是一个对象，但是typeof做了区分，Array也是一个对象。但是typeof没有作区分。这就是js的设计者做的很多不完美的地方。留了很多缺陷。有一篇文章详细剖析了type of 返回object 这一个bug的具体信息。可以点击[这里](http://www.2ality.com/2013/10/typeof-null.html)查看\r\n\r\n### instanceof ###\r\ninstanceof检测值是不是一个构造函数的实例。但这里需要注意的是基本数据类型使用instanceof都会返回false。\r\n\r\n```\r\n\"aaa\" instanceof String  //false\r\n\r\nvar a = new String(\"aaa\") \r\na instanceof String  //true\r\n\r\n```\r\n思考一下以上两种方式为何会出现不同的结果? 为什么\"aaa\".length和\"aaa\".subString()这些String对象上的方法可以被基本数据类型使用。其实可以这样去理解，基本数据类型自身不是对象。但是在运行环境中。js会自动帮他们生产虚拟的对象。运行结束之后，这些虚拟对象被销毁。\r\n\r\n那接下来思考一下几个问题：\r\n\r\n1.如何判断一个变量是string类型？\r\n\r\n```\r\nfunction isString(s){\r\n\tif(typeof s == \"string\"){\r\n\t\treturn true;\r\n\t}else if(typeof s ==\"object\" && s instanceof== \"String\"){\r\n\t\treturn true;\r\n\t}else{\r\n\t\treturn false;\r\n\t}\r\n}\r\n\r\n```\r\n\r\n2.如何判断一个变量是数组呢？\r\n\r\n最简单的方法是如下写法。\r\n\r\n```\r\nfunction isArray(value){\r\n\treturn value instanceof Array;\t\r\n}\r\n\r\n```\r\n这样写一般也不会遇到啥大问题。但是[在不同 iframe 中创建的 Array 并不共享 prototype](http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/)\r\n\r\n所以想要严谨一些。兼容iframe这种情况的话。可以用如下的方法。\r\n\r\n```\r\n\r\nvar isArray = function(obj) { \r\n    return Object.prototype.toString.call(obj) === '[object Array]'; \r\n}\r\n\r\n```\r\n\r\n3.写一个通用的判断各种类型的方法如何？\r\n\r\n```\r\nvar is = function (obj,type) { \r\n\treturn (type === \"Null\" && obj === null) || \r\n\t\t\t(type === \"Undefined\" && obj === void 0 ) || \r\n\t\t\t(type === \"Number\" && isFinite(obj)) || \r\n\t\t\tObject.prototype.toString.call(obj).slice(8,-1) === type; \r\n}\r\n\r\n```\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}